#!/usr/bin/perl
#
# Override the current configuration on a switch with the appropriate configuration file from
# the output directory. Uses SCP to place the configuratino file and then uses SSH to load and
# activate it.

# Based on override_switches script, but optimized for sequential bulk loading of switches in sequence
#
# General theory:
#     Each switch should have a common configuration on the management ethernet interface (me-0):
#        192.168.255.76/24 (If this changes, update the $IP variable definition below)
#
#    The system where this software is running should have an interface set up on that same network.
#
#    1. ping 192.168.255.76 until success
#    2. Get MAC address of 192.168.255.76 from ARP table.
#    3. Identify switch name based on MAC address lookup in switchtypes file (column 9 Mgmt MAC -> Column 1 Name)
#    4. Load appropriate configuration from "output" directory onto switch based on the name.
#    5. When complete, notify user and ping 192.168.255.76 until failure.
#    6. Repeat beginning with step 1 above.

my $IP = "192.168.255.76"; # Switch target management IP
my $SSH = "/usr/bin/ssh";  # Location of ssh binary

# Pull in dependencies
use strict;
require "./scripts/switch_template.pl";
use FileHandle;
use IPC::Open2;
use Net::Ping;
use Expect;
use Term::ReadKey;
use Getopt::Std;
our $opt_n;
our $opt_l = 1;
our $opt_u = "";
getopts('nu:');

# -n -- Don't actually apply the configuration, just show the compare and then roll back.

STDERR->autoflush(1);   # Turn on autoflush for STDERR

# Prime the switch database
get_switchtype("anonymous");

my $ping = Net::Ping->new("icmp");

while (1) {
    
    # delete ARP entry for 192.168.255.76 (Requires sudo for privileges)
    # Turns out to be unnecessary and annoying.
    # system("sudo", "arp","-d","$IP");
    
    # ping $IP until success
    my $success = 0;
    print "Looking for switch on line.\n";
    do {
        my $result = $ping->ping($IP);
        $success++ unless($result);
        sleep 1; # Retry every second until success.
    } until($success);
    
    print "Switch detected, identifying.\n";
    my $arp = `arp -n $IP | grep $IP`;
    chomp($arp);
    $arp = lc($arp);
    # Harry regex to support differing arp outputs (BSD vs. Linux vs. MacOS)
    $arp =~ s@^.*(at|ether)\s+([0-9a-f:]+)\s+.*$@\2@m;
    if ($arp =~ /\n/)
    {
        warn("Multiple ARP table entries for address $IP:\n");
        foreach(split(/\n/, $arp))
        {
            warn("\t$_\n");
        }
        warn("Basing configuration load on first one.\n");
        $arp =~ s/\n.*//;
    }
    
    print "Looking for MAC $arp in switchtypes table...";
    my @switchname = get_switch_by_mac($arp);
    print "Got ", scalar(@switchname), " names back from get_switch_by_mac($arp)\n";
    
    if (scalar(@switchname) < 1)
    {
        print STDERR "Error: No switchtype entry matching $arp\n";
        sleep 10;
        next; # Retry -- until file is corrected or a valid switch is provided
    }
    elsif (scalar(@switchname) > 1)
    {
        print STDERR "Error: $arp matches multiple switches (", join(", ", @switchname),").\n";
        sleep 10;
    get_switchtype("anonymous");
        continue; # Retry -- until file is corrected or a valid switch is provided
    }
    print "Found: $switchname[0].\n";
    my $switch = $switchname[0];

    # Assertions:
    #   output/* contains valid configuration files for each switch
    #   Switches are accessible via SSH at their management address in the switchtypes file.
    #    (unless -l in which case accessible via SSH on attached management interface)
    # Phase 1: Push new configuration file to switch.
    # Phase 2: Apply new configuration file using "load override <filename>" and commit it.
    #
    
    # Commands used for phase 2
    my $SWITCH_COMMANDS;
    unless ($opt_n) {
        $SWITCH_COMMANDS = <<EOF;
edit
load override /tmp/new_config.conf
show | compare
commit and-quit
exit
EOF
    }
    else
    {
        $SWITCH_COMMANDS = <<EOF;
edit
load override /tmp/new_config.conf
show | compare
rollback
exit
exit
EOF
    }
    
    $SIG{PIPE} = \&catch_pipe;
    
    my ($Name, $Num, $MgtVL, $IPv6Addr, $Type);
    print "Looking up switch $switch\n";
    ($Name, $Num, $MgtVL, $IPv6Addr, $Type) = (get_switchtype($switch));
    die("Error: Couldn't get type for $switch (got $Name)\n") unless $Name eq $switch; 
    print "Got Entry:  $Name, $Num, $MgtVL, $IPv6Addr, $Type for $switch\n";

    # Phase 1: Copy configuration to device
    if (!-f "output/$Name.conf")
    {
        die("Error: Couldn't read configuration file for $Name");
    }
    # I hate using system() here, but so far, it's the most reliable alternative.
    print STDERR "Sending configuration file to $Name\n";
    if ($opt_l) # If -l is specified, install configuration via directly attached management port
    {
        my $result;
        my $CMD ="scp \"output/$Name.conf\" ";
        $CMD .= $opt_u ? "$opt_u\@" : "";
        $CMD .= "$IP" . ":/tmp/new_config.conf";
        if($result = system($CMD))
        {
            while ($result == 1 || $result == 256)
            {
                # Connection error, probably switch isn't fully online
                print STDERR "Switch didn't accept SCP, retrying in 5 seconds.\n";
                sleep 5; 
                $result = system($CMD);
            }
            if ($result)
            {
                # Something else went wrong, probably can't recover.
                die("Failed to copy configuration (on retry) to device $Name ($result : $!)\n");
            }
        }
    }
    else
    {
        die("Failed to copy configuration to device $Name ($? : $!)\n") if 
            system("scp \"output/$Name.conf\" $Name".":/tmp/new_config.conf");
    }
    
    print STDERR "Activating...\n";
    my $TARGET;
    if ($opt_l) # If -l is specified, activate configuration via directly attached management port
    {
        $TARGET = $opt_u ? "$opt_u\@$IP" : "$IP";
    }
    else
    {
        $TARGET = $opt_u ? "$opt_u\@$Name" : "$Name";
    }
    my $JUNIPER = new Expect;
    $JUNIPER->raw_pty(1);
    $JUNIPER->spawn($SSH, $TARGET);
    # Initial connect will get us one of five possible situations:
    my ($pos, $err, $matched, $before, $after) = $JUNIPER->expect(30,
        'WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!',
        'Are you sure you want to continue connecting',
        'Enter passphrase',
        'password:',
        '> ');

    # Remote Key Change
    if ($matched =~ /REMOTE HOST IDENTIFICATION/)
    {
        die("Error: Remote Host Key change detected, cannot continue. Please check ~/.ssh/known_hosts.\n");
    }
    # Handle prompt for host key not recognized
    if ($matched =~ /continue connecting/)
    {
        warn("Host key changed, accepting new key.\n");
        $JUNIPER->send("yes\n");
        # Look for next response
        ($pos, $err, $matched, $before, $after) = $JUNIPER->expect(30,
            'Enter passphrase',
            'password:',
        '> ');
    }
    # Handle prompt for passphrase (for key) or password (host)
    if ($matched =~ /pass/)
    {
      if ($matched =~ /:/)
      {
        print "Remote Host requests password: ";
      }
      else
      {
        print "SSH Key requires password: ";
      }
      # Get password from STDIN
      ReadMode('noecho');
      my $pass = ReadLine(0);
      ReadMode('normal');
      chomp($pass);
      print "\n";
      my $success = 0;
      do {
      # Get password from STDIN
        ReadMode('noecho');
        my $pass = ReadLine(0);
        ReadMode('normal');
        chomp($pass);
        print "\n";
        $JUNIPER->send($pass,"\n");
        ($pos, $err, $matched, $before, $after) = $JUNIPER->expect(30,
            'passphrase',
            'password:',
            '> ');
        if ($matched =~ /pass/)
        {
            print "(More) authentication required:\n");
            if ($matched =~ /:/)
            {
              print "Remote Host requests password: ";
            }
            else
            {
              print "SSH Key requires password: ";
            }
        }
        else
        {
            $success++;
        }
      } until ($success);
    }
    # Finally at the router prompt, logged in.
    #print JUNIPER $SWITCH_COMMANDS;
    #print STDERR "Finished sending commands to switch...\n";
    #unless(close JUNIPER)
    #{
    #    warn "Switch $Name Bad exit from SSH: $! $?\n";
    #}
    #else
    #{
    #    print STDERR "$Name successfully loaded.\n";
    #}

    # Wait for the switch to go off line before trying to find next switch.
    $success = 1;
    do {
        my $result = $ping->ping($IP);
    $success=0 if($result);
        sleep 1; # Retry every second until success.
    } while($success);
    
    print STDERR "\n\nReady for next switch.\n\n";
    
}


sub catch_pipe {
    my $signame = shift;
    print STDERR "Pipe signal cauthg ($signame) $! $?\n";
}

